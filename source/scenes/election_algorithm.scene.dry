title: Election
on-arrival: {!
// Normalize class support (0â€“100)
for (var c of Q.classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
        if (Q[c + '_' + party] < 0) Q[c + '_' + party] = 0;
        class_votes += Q[c + '_' + party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100 * Q[c + '_' + party] / class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100 * Q[c + '_' + party] / class_votes);
    }
}
// Reset Senate seats
for (var party of Q.parties) {
    Q[party + '_senate_seats'] = 0;
}
// Each state gets 2 Senate seats (winner-takes-all, top 2 parties per state)
for (var state of Q.states) {
    var state_support = [];
    for (var party of Q.parties) {
        var support = 0;
        for (var c of Q.classes) {
            var class_percent = Q[c] || 0; // Replace with Q[state + '_' + c] if using state-specific
            if (Q.old_demographics) {
                support += class_percent * (Q[c + '_' + party] || 0);
            } else {
                support += class_percent * (Q[c + '_' + party + '_normalized'] || 0);
            }
        }
        state_support.push({ party: party, support: support });
    }
    // Sort by support descending
    state_support.sort((a, b) => b.support - a.support);

    // Assign 2 Senate seats to top 2 parties (both get 1 seat)
    Q[state + '_senate_winner_1'] = state_support[0].party;
    Q[state + '_senate_winner_2'] = state_support[1].party;

    Q[state_support[0].party + '_senate_seats'] += 1;
    Q[state_support[1].party + '_senate_seats'] += 1;
}

// Track overall Senate seat results for each party
Q.rep_votes = Q["rep_senate_seats"];
Q.dem_votes = Q["dem_senate_seats"];
Q.other_votes = (Q["lib_senate_seats"] || 0) + (Q["green_senate_seats"] || 0); // adjust if you have more parties
Q.vac_r = 0; // If you simulate unfilled seats or ties, set this as needed
!}
go-to: jumpScene


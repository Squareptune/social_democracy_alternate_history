title: Election
on-arrival: {!
// Normalize class support (0â€“100) for each state
for (var c of Q.classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
        if (Q[c + '_' + party] < 0) Q[c + '_' + party] = 0;
        class_votes += Q[c + '_' + party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100 * Q[c + '_' + party] / class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100 * Q[c + '_' + party] / class_votes);
    }
}
// Reset Senate seats
for (var party of Q.parties) {
    Q[party + '_senate_seats'] = 0;
}
// Each state gets 2 Senate seats
for (var state of Q.states) {
    var state_support = [];
    // Calculate party support for each state
    for (var party of Q.parties) {
        var support = 0;
        for (var c of Q.classes) {
            // Get state-specific class population
            var state_class_population = Q[state + '_' + c] || 0; // Default to 0 if no value is set for the state_class combination
            // Calculate the weighted support based on class population and normalized support
            support += state_class_population * (Q[c + '_' + party + '_normalized'] || 0);
        }
        state_support.push({ party: party, support: support });
    }
    // Sort by support in descending order and assign 2 Senate seats to top 2
    state_support.sort((a, b) => b.support - a.support);
    Q[state + '_senate_winner_1'] = state_support[0].party;
    Q[state + '_senate_winner_2'] = state_support[1].party;

    // Allocate 1 Senate seat to each of the top 2 parties in the state
    Q[state_support[0].party + '_senate_seats'] += 1;
    Q[state_support[1].party + '_senate_seats'] += 1;
}

// Calculate total Senate votes
Q.rep_votes = Q["rep_senate_seats"];
Q.dem_votes = Q["dem_senate_seats"];
Q.other_votes = (Q["lib_senate_seats"] || 0) + (Q["green_senate_seats"] || 0); // adjust if you have more parties
Q.vac_r = 0; // If you simulate unfilled seats or ties, set this as needed
!}
go-to: jumpScene


title: Post Event
new-page: true
on-arrival: {!
Q.last_advisor_action = 0;
Q.last_cabinet_action = 0;

// Clamp out of bound class-party values
for (let c of Q.classes) {
    for (let party of Q.parties) {
        if (Q[c + '_' + party] < 0) Q[c + '_' + party] = 0;
        if (Q[c + '_' + party] > 100) Q[c + '_' + party] = 100;
    }
}

// Clamp pro_republic
Q.pro_republic = Math.min(Math.max(Q.pro_republic, 0), 99);

for (let c of Q.classes) {
    let classVotes = 0;
    for (let party of Q.parties) classVotes += Q[c + '_' + party];
    if (classVotes === 0) classVotes = 1; // prevent divide by zero
    for (let party of Q.parties) {
        let val = Q[c + '_' + party];
        let normalized = val / classVotes;
        Q[c + '_' + party + '_normalized'] = normalized;
        Q[c + '_' + party + '_display'] = Math.min(100, Math.round(100 * normalized));
    }
}

// Party support
let totalSupport = 0;
for (let party of Q.parties) {
    let support = 0;
    for (let c of Q.classes) {
        if (Q.old_demographics) support += Q[c] * Q[c + '_' + party];
        else support += Q[c] * Q[c + '_' + party + '_normalized'];
    }
    Q[party + '_support'] = support;
    totalSupport += support;
}

// Normalize overall party support
for (let party of Q.parties) {
    Q[party + '_normalized'] = totalSupport ? Q[party + '_support'] / totalSupport : 1 / Q.parties.length;
    Q[party + '_votes'] = Math.round(Q[party + '_normalized'] * 100);
    Q[party + '_votes_display'] = Q[party + '_votes'];
}

// === House Projections ===
let repVotesHouse = 0, demVotesHouse = 0, otherVotesHouse = 0;

for (let state of Q.states) {
    for (let cls of Q.classes) {
        let pop = Q[state + "_" + cls] || 0;
        let rep = Q[state + "_" + cls + "_rep"] || 0;
        let dem = Q[state + "_" + cls + "_dem"] || 0;
        let other = Q[state + "_" + cls + "_other"] || 0;

        let repMod = Q[cls + "_rep"] || 0;
        let demMod = Q[cls + "_dem"] || 0;
        let otherMod = Q[cls + "_other"] || 0;

        let adjRep = 0.2 * rep + 0.8 * repMod;
        let adjDem = 0.2 * dem + 0.8 * demMod;
        let adjOther = 0.2 * other + 0.8 * otherMod;

        let totalPct = adjRep + adjDem + adjOther;
        if (totalPct === 0) continue;

        repVotesHouse += pop * (adjRep / totalPct);
        demVotesHouse += pop * (adjDem / totalPct);
        otherVotesHouse += pop * (adjOther / totalPct);
    }
}

// Cube law proportional allocation
let totalVotesHouse = repVotesHouse + demVotesHouse + otherVotesHouse;
if (totalVotesHouse === 0) totalVotesHouse = 1; // prevent NaN
let repShare = repVotesHouse / totalVotesHouse;
let demShare = demVotesHouse / totalVotesHouse;
let otherShare = otherVotesHouse / totalVotesHouse;

Q.rep_r_pro = Math.floor(repShare * (Q.total_house_seats || 241));
Q.dem_r_pro = Math.floor(demShare * (Q.total_house_seats || 241));
Q.other_r_pro = (Q.total_house_seats || 241) - Q.rep_r_pro - Q.dem_r_pro;

// === Senate Projections ===
Q.rep_senate_pro = 0;
Q.dem_senate_pro = 0;
Q.other_senate_pro = 0;

for (let state of Q.states) {
    let repVotes = 0, demVotes = 0, otherVotes = 0;

    for (let cls of Q.classes) {
        let pop = Q[state + "_" + cls] || 0;
        let localRep = Q[state + "_" + cls + "_rep"] || 0;
        let localDem = Q[state + "_" + cls + "_dem"] || 0;
        let localOther = Q[state + "_" + cls + "_other"] || 0;

        let nationalRep = Q[cls + "_rep"] || 0;
        let nationalDem = Q[cls + "_dem"] || 0;
        let nationalOther = Q[cls + "_other"] || 0;

        let adjRep = 0.8 * localRep + 0.2 * nationalRep;
        let adjDem = 0.8 * localDem + 0.2 * nationalDem;
        let adjOther = 0.8 * localOther + 0.2 * nationalOther;

        let total = adjRep + adjDem + adjOther;
        if (total === 0) continue;

        repVotes += pop * (adjRep / total);
        demVotes += pop * (adjDem / total);
        otherVotes += pop * (adjOther / total);
    }

    let totalVotes = repVotes + demVotes + otherVotes;
    if (totalVotes === 0) continue;

    let repPct = (repVotes / totalVotes) * 100;
    let demPct = (demVotes / totalVotes) * 100;
    let otherPct = (otherVotes / totalVotes) * 100;

    let results = [
        { party: "rep", pct: repPct },
        { party: "dem", pct: demPct },
        { party: "other", pct: otherPct }
    ].sort((a, b) => b.pct - a.pct);

    let first = results[0], second = results[1];
    let repSeats = 0, demSeats = 0, otherSeats = 0;

    if (first.pct >= 66 || (first.pct >= 55 && first.pct - second.pct > 10)) {
        if (first.party === "rep") repSeats = 2;
        else if (first.party === "dem") demSeats = 2;
        else otherSeats = 2;
    } else if (first.pct - second.pct <= 12) {
        if (first.party === "rep") repSeats++;
        else if (first.party === "dem") demSeats++;
        else otherSeats++;

        if (second.party === "rep") repSeats++;
        else if (second.party === "dem") demSeats++;
        else otherSeats++;
    } else {
        if (first.party === "rep") repSeats = 2;
        else if (first.party === "dem") demSeats = 2;
        else otherSeats = 2;
    }

    Q.rep_senate_pro += repSeats;
    Q.dem_senate_pro += demSeats;
    Q.other_senate_pro += otherSeats;
}

// set faction strength/dissent to 0
for (var c of Q.factions) {
    if (Q[c+'_dissent'] < 0) {
        Q[c+'_dissent'] = 0;
    } else if (Q[c+'_dissent'] >= 100) {
        Q[c+'_dissent'] = 99;
    }
    if (Q[c+'_strength'] < 0) {
        Q[c+'_strength'] = 0;
    }
}

if (Q.unemployed <= 1) {
    Q.unemployed = 1;
}

// re-calculate dissent.
var total_strength = Q.radical_strength + Q.moderate_strength + Q.conservative_strength + Q.liberal_strength;

// Prevent division by zero
if (total_strength <= 0) {
    Q.radical_strength = 25;
    Q.moderate_strength = 25;
    Q.conservative_strength = 25;
    Q.liberal_strength = 25;
    total_strength = 100;
} else {
    Q.radical_strength = 100 * Q.radical_strength / total_strength;
    Q.moderate_strength = 100 * Q.moderate_strength / total_strength;
    Q.conservative_strength = 100 * Q.conservative_strength / total_strength;
    Q.liberal_strength = 100 * Q.liberal_strength / total_strength;
}

var total_dissent = Q.radical_strength*Q.radical_dissent + Q.moderate_strength*Q.moderate_dissent + Q.conservative_strength* Q.conservative_dissent + Q.liberal_strength*Q.liberal_dissent


Q.dissent = 0.01*total_dissent/total_strength;
Q.dissent_percent = Q.dissent*100;
console.log('new dissent: ' + Q.dissent);

if (Q.dissent < 0) {
    Q.dissent = 0;
} else if (Q.dissent > 0.95) {
    Q.dissent = 0.95;
}

Q.Base_Support = 0.35 * Q.freemen_rep + 0.20 * Q.workers_rep + 0.20* Q.middle_class_rep + 0.15 * Q.immigrant_laborers_rep + 0.10 * Q.unemployed_rep;

Q.ViolencePenalty = (Q.kkk_strength * Q.kkk_militancy * 0.4) + (Q.whiteL_strength * Q.whiteL_militancy * 0.6);

Q.FatiguePenalty = min(Q.year - 1865, 10);

Q.reconstruction_support = Q.Base_Support - Q.ViolencePenalty - Q.FatiguePenalty - min(Q.PoliticalCostPenalty * 0.25, 15);


//Amendments 

let supportiveStates = 0;
let totalStates = Q.states.length;

for (let state of Q.states) {
  let repVotes = 0;
  let demVotes = 0;
  let otherVotes = 0;

  for (let cls of Q.classes) {
    
    if (cls === "freemen" && Q.fifthteen == 0){
        // skip freemen if 15th amendment not passed
    }
    else{
        let pop = Q[state + "_" + cls] || 0;

        let rep = Q[state + "_" + cls + "_rep"] || 0;
        let dem = Q[state + "_" + cls + "_dem"] || 0;
        let other = Q[state + "_" + cls + "_other"] || 0;

        let repMod = Q[cls + "_rep"] || 0;
        let demMod = Q[cls + "_dem"] || 0;
        let otherMod = Q[cls + "_other"] || 0;

        let adjRep = 0.2 * rep + 0.8 * repMod;
        let adjDem = 0.2 * dem + 0.8 * demMod;
        let adjOther = 0.2 * other + 0.8 * otherMod;

        let totalAdj = adjRep + adjDem + adjOther;
        if (!totalAdj) continue;

        repVotes += pop * (adjRep / totalAdj);
        demVotes += pop * (adjDem / totalAdj);
        otherVotes += pop * (adjOther / totalAdj);
    }
  }

  if (repVotes > demVotes && repVotes > otherVotes) {
    supportiveStates++;
  }
}

// 3/4 state threshold
let requiredStates = Math.ceil(0.75 * totalStates);


Q.amendmentResult = (supportiveStates >= requiredStates) ? 1 : 0;

for (let state of Q.southern_states) {

  // --- Calculate white loyalty ---
  let white_loyalty = 0;
  let white_pop = 0;

  for (let cls of Q.classes) {
    if (cls === "freemen") continue;

    let pop = Q[state + "_" + cls] || 0;
    let repPct = (Q[state + "_" + cls + "_rep"] || 0) / 100;

    white_loyalty += pop * repPct;
    white_pop += pop;
  }

  if (white_pop > 0) {
    white_loyalty = (white_loyalty / white_pop) * 100;
  }

  // --- Enforcement & resistance (GLOBAL variables) ---
  let occupation = Q.occupation || 0;       // 0–2
  let judicial = Q.judical_reform || 0;           // grows slowly
  let kkk = Q.kkk_strength || 0;                   // 0–100
  let whiteL = Q.whiteL_strength || 0;             // 0–100
  let unionLeague = Q.Union_League_strength || 0;  // 0–100

  // --- State loyalty ---
  let state_loyalty =
      white_loyalty
    + (occupation * 10)
    + judicial
    - ((kkk + whiteL) * (1 - white_loyalty / 100));

  state_loyalty = Math.max(0, Math.min(100, Math.round(state_loyalty)));
  Q[state + "_loyalty"] = state_loyalty;

  // --- Race equality support ---
  let freedmen_rep = Q[state + "_freemen_rep"] || 0;

  let raceEqualitySupport =
      freedmen_rep
    + (white_loyalty * 0.4)
    + (unionLeague * 0.6)
    + (occupation * 10)
    - ((kkk + whiteL) * (1 - freedmen_rep / 100));

  raceEqualitySupport = Math.max(0, Math.min(100, Math.round(raceEqualitySupport)));
  Q[state + "_raceEqualitySupport"] = raceEqualitySupport;

  // --- Reconstruction score ---
  let score = 0;
  let threshold = 0;

  if (Q.Johnson_plan === 1) {
    score = 0.9 * state_loyalty + 0.3 * white_loyalty;
    threshold = 35;
  }

  if (Q.Moderate_plan === 1) {
    score = 0.4 * white_loyalty + 0.4 * raceEqualitySupport + 0.4 * state_loyalty;
    threshold = 70;
  }

  if (Q.Radical_plan === 1) {
    score = 0.15 * white_loyalty + 0.7 * raceEqualitySupport + 0.7 * state_loyalty;
    threshold = 90;
  }

  score = Math.round(score);
  Q[state + "_reconstructionScore"] = score;
  Q[state + "_canReadmit"] = score >= threshold;
}


// 1. update dates
if (Q.month_actions >= 1) {
    Q.time += 1;
    Q.month_actions = 0;
    Q.month += 1;
    if (Q.month >= 13) {
        Q.month = 1;
        Q.year += 1;
        if (Q.historical_mode) {
            Q.resources += 2;
        }
    }
    // decrement timers
    for (timer of Q.timers) {
        if (Q[timer+'_timer'] && Q[timer+'_timer'] > 0) {
            Q[timer+'_timer'] -= 1;
        }
    }
    // append to historical party support records
    var party_support_results = {'date': new Date(Q.year, Q.month - 1)};
    for (var party of Q.parties) {
        party_support_results[party] = Q[party + '_normalized']*100;
    }
    Q.party_support_records.push(party_support_results);
    Q.economic_records.push({'date': new Date(Q.year, Q.month - 1),
                             'inflation': Q.inflation,
                             'unemployment': Q.unemployed});
    // change economic stats...
    // we're basically implicity drawing a Philips curve
    // budget deficits lead to some inflation
    if (Q.budget <= 0 && Q.budget > -2 && Q.inflation < 2.5) {
        Q.inflation += 0.1;
    }
    if (Q.budget <= -2 && Q.budget > -5 && Q.inflation < 5) {
        Q.inflation += 0.2;
        if (Q.unemployed >= 12) {
            Q.inflation -= 0.1;
        }
    }
    if (Q.budget <= -5 && Q.inflation < 10) {
        Q.inflation += 0.3;
        if (Q.unemployed >= 15) {
            Q.inflation -= 0.1;
        }
    }
    // deflation is bad
    if (Q.inflation < -0.5 && Q.inflation > -5 && Q.unemployed < 15) {
        Q.unemployed += 0.2;
    }
    if (Q.inflation <= -5 && Q.unemployed < 20) {
        Q.unemployed += 0.3;
    }
    // economic growth
    if (Q.economic_growth < -0.5 && Q.unemployed <= 18) {
        Q.unemployed += 0.1;
    }
    if (Q.economic_growth < -5 && Q.unemployed <= 28) {
        Q.unemployed += 0.1;
    }
    if (Q.economic_growth >= 2 && Q.unemployed >= 17) {
        Q.unemployed -= 0.1;
    }
    if (Q.economic_growth >= 4 && Q.unemployed >= 12) {
        Q.unemployed -= 0.1;
    }
    if (Q.economic_growth >= 6 && Q.unemployed >= 7) {
        Q.unemployed -= 0.1;
    }
    if (Q.economic_growth >= 8 && Q.unemployed >= 3) {
        Q.unemployed -= 0.1;
    }
    if (Q.economic_growth >= 4 && Q.inflation >= 7.5) {
        Q.economic_growth -= 0.1;
    }
    if (Q.economic_growth >= -2.5 && Q.inflation <= -5) {
        Q.economic_growth -= 0.1;
    }
    if (Q.economic_growth >= 7) {
        Q.economic_growth -= 0.1;
    }
    if (Q.economic_growth >= 10) {
        Q.economic_growth -= 0.2;
    }
    if (Q.economic_growth >= 12) {
        Q.economic_growth -= 0.3;
    }

    //////////////////////////////// Education & Science support/economic changes
    if (Q.major_curriculum && Q.major_curriculum == "democratic") {
        if (Q.pro_republic < 60) {
            Q.pro_republic += 0.5;
        } 
    }
    if (Q.minor_curriculum && Q.minor_curriculum == "democratic") {
        if (Q.pro_republic < 60) {
            Q.pro_republic += 0.3;
        } 
    }
    // science bonus to economic growth
    // education bonus
    Q.science_bonus = 0;
    if (Q.education_science) {
        Q.science_bonus += Q.education_science;
    }
    if (Q.science) {
        if (Q.science >= 1) {
            Q.science_bonus += 1;
        } else if (Q.science >= 3) {
            Q.science_bonus += 2;
        } else if (Q.science >= 5) {
            Q.science_bonus += 3;
        }
    }
    if (Q.applied_research && Q.applied_research >= 1) {
        Q.science_bonus += 0.5*Q.applied_research;
    }
    // cap the science bonus at 6
    if (Q.science_bonus > 6) {
        Q.science_bonus = 6;
    }
    console.log(Q.science_bonus);
    // this is kinda messy but basically more science -> higher levels of baseline growth
    if (Q.science_bonus >= 1) {
        if (Q.return_to_normalcy && Q.economic_growth < Q.science_bonus + 3) {
            Q.economic_growth += 0.1;
        }
        if (Q.return_to_normalcy && Q.economic_growth < Q.science_bonus) {
            Q.economic_growth += 0.1;
        }
        if (Q.economic_growth < Q.science_bonus - 3) {
            Q.economic_growth += 0.1;
        }
    }
    // accumulated economic growth/decline
    // Maybe there should be differences for positive/negative growth?
    if (Q.economic_growth < 0) {
        if (Q.economic_expansion > 0) {
            Q.economic_expansion = 0;
        } else {
            Q.economic_expansion += Q.economic_growth;
        }
    }
    if (Q.economic_growth > 0 && Q.reparations <= -2 && Q.spd_in_government) {
        Q.economic_expansion += Q.economic_growth;
    } else if (Q.economic_growth > 0 && Q.spd_in_government) {
        Q.economic_expansion += Q.economic_growth/2;
    }
    /////////////////////////////// update opinions based on economy
    if (Q.unemployed > 15 && Q.pro_republic > 40) {
        Q.pro_republic -= 1;
    }
    if (Q.unemployed > 30 && Q.pro_republic > 20) {
        Q.pro_republic -= 1;
    }
    if (Q.inflation >= 8 && Q.pro_republic > 40) {
        Q.pro_republic -= 1;
    }

    ///////////////////////////// change party support based on pro_republic
    // if pro_republic is less than the support of the Weimar coalition, reduce SPD support...
    if (Q.pro_republic < (Q.spd_votes + Q.ddp_votes + Q.z_votes - 3)) {
        if (Q.new_middle_spd > 0) {
            Q.new_middle_spd -= 5/12;
            Q.new_middle_nsdap += 3/12;
        }
        if (Q.old_middle_spd > 0) {
            Q.old_middle_spd -= 5/12;
            Q.old_middle_nsdap += 3/12;
        }
        if (Q.rural_spd > 0) {
            Q.rural_spd -= 5/12;
            Q.rural_nsdap += 3/12;
        }
        if (Q.workers_spd_normalized > 30) {
            Q.workers_spd -= 4/12;
        }
        if (Q.catholics_spd > 0) {
            Q.catholics_spd -= 4/12;
        }
        if (Q.unemployed_spd_normalized > 10) {
            Q.unemployed_spd -= 4/12;
        }
        if (Q.new_middle_ddp > 0) {
            Q.new_middle_ddp -= 4/12;
            Q.new_middle_nsdap += 3/12;
        }
        if (Q.old_middle_ddp > 0) {
            Q.old_middle_ddp -= 5/12;
            Q.old_middle_nsdap += 4/12;
        }
        if (Q.rural_ddp > 0) {
            Q.rural_ddp -= 5/12;
            Q.rural_nsdap += 4/12;
        }
    }
    // BASELINE GROWTH / SUPPRESSION (monthly)
    if (Q.occupation == 0) {
        Q.kkk_strength += 0.06;   // +720 per year
    } else if (Q.occupation == 1) {
        Q.kkk_strength += 0.02;   // +240 per year
    } else if (Q.occupation == 2) {
        Q.kkk_strength -= 0.05;   // -600 per year
    }

    // POLICE LOYALTY EFFECT
    if (Q.Us_police_loyalty < 0.41) {
        Q.kkk_strength += 0.03;   // +360 per year
    } else if (Q.Us_police_loyalty > 0.71) {
        Q.kkk_strength -= 0.02;   // -240 per year
    }

    // STATE MILITIAS (scales with strength)
    if (Q.state_militia_formed == 1) {
        Q.kkk_strength -= (Q.state_militia_strength * 0.00015);
    }

    // UNION LEAGUE BACKLASH
    if (Q.Union_League_strength > 60) {
        Q.kkk_strength += 0.02;   // +240 per year
    }
    // RADICAL RECONSTRUCTION BACKLASH
    if (Q.Union_League_militancy > 0.4) {
        Q.kkk_militancy += 0.004;
    }

    // WEAK ENFORCEMENT RADICALIZES
    if (Q.occupation == 0 && Q.Us_police_loyalty < 0.41) {
        Q.kkk_militancy += 0.003;
    }

    // STRONG ENFORCEMENT CONTAINS VIOLENCE
    if (Q.occupation == 2 && Q.army_loyalty > 0.75) {
        Q.kkk_militancy -= 0.005;
    }

    // KKK BAN EFFECT (UNDERGROUND EFFECT)
    if (Q.kkk_banned == 1) {
        Q.kkk_strength -= 0.04;   // -480 per year
        Q.kkk_militancy += 0.006;
    }
    Q.kkk_strength = Math.max(Q.kkk_strength, 0);
    Q.kkk_militancy = Math.min(1.5, Math.max(0.01, Q.kkk_militancy));
    ////////////////////////// annual support changes
    }

Q.has_event = 0;
// check if there are any cards in #event, and then go to main if not.
var scene = this.game.scenes['post_event.events_choice'];
var choices = this._compileChoices(scene);
if (choices && choices[0].title != "Continue...") {
    Q.has_event = 1;
} else {
    Q.has_event = 0;
}
// pre-load all of the event images
if (this.ui && this.ui.show_portraits) {
    for (var choice of choices) {
        var cc = this.game.scenes[choice.id];
        if (cc.faceImage) {
            var im = new Image();
            im.url = cc.faceImage;
        }
    }
}

if (typeof window !== "undefined" && window.generateBar) {
}
!}
go-to: events_choice if has_event = 1; main if has_event = 0 and difficulty >= 0; main.main_easy if has_event = 0 and difficulty < 0

= [+ month : month +] [+ year +]

@events_choice

- #event

# This scene is solely for updating numbers after events, and routing to special events.
